# command-detection

## 目的

- 言語依存の前提を置かず、テスト実行コマンドを 1 つに確定する。
- 確定前に実行可能性を自動プローブして、計画をそのまま実行できる状態にする。

## 検出順序

1. ユーザーが明示したテストコマンドを最優先で使う。
2. マニフェストとロックファイルからプロジェクト種別を判定する。
3. 判定結果から候補コマンドを優先順で並べる。
4. 候補コマンドを上から順に自動プローブする。
5. 最初に `PASS` した候補を確定する。
6. すべての候補が `SOFT_FAIL` または `HARD_FAIL` の場合だけ 1 回確認質問を行う。
7. 回答後に再プローブし、それでも `PASS` しなければ停止する。
8. 確定後は同じセッションでコマンドを固定する。

## 判定ルール

- `package.json` がある場合:
  - `pnpm-lock.yaml` があるなら `pnpm test` を優先する。
  - `yarn.lock` があるなら `yarn test` を優先する。
  - それ以外は `npm test` を使う。
- `pyproject.toml` または `pytest.ini` がある場合は `pytest -q` を使う。
- `go.mod` がある場合は `go test ./...` を使う。
- `Cargo.toml` がある場合は `cargo test` を使う。
- `gradlew` がある場合は `./gradlew test` を使う。
- `pom.xml` がある場合は `mvn test -q` を使う。
- `*.sln` または `*.csproj` がある場合は `dotnet test` を使う。

## 自動プローブ判定

- `PASS`: ランチャーが存在し、対象プロジェクトでテスト起動条件を満たす。
- `SOFT_FAIL`: ランチャーは存在するが、対象テストタスクを見つけられない。
- `HARD_FAIL`: ランチャーが存在しない、または即時エラーで起動できない。
- `PASS` が 1 件でもあれば確定する。
- `SOFT_FAIL` と `HARD_FAIL` のみの場合は確認質問に進む。

## プローブ手順

1. ランチャー存在確認を行う。例: `command -v pnpm`。
2. タスク存在確認を行う。例: `package.json` の `scripts.test` を確認する。
3. 必要な場合だけ軽量実行確認を行う。例: テスト一覧取得や `--help` が使えるコマンドを使う。
4. 実テストを走らせる重いプローブは行わない。

## コマンド確定後の扱い

- `plan-only` でも確定コマンドを必須で出力する。
- 確定値は `Execution Handoff` と `Validation` の両方に同じ文字列で記載する。
- 途中で新しい候補を追加しない。

## 確認質問テンプレート

```text
自動プローブで有効なテストコマンドを確定できませんでした。候補は `<candidate_list>` です。どれで実行しますか？
```

## 停止時に必ず出す情報

- 試した候補一覧。
- 各候補の `PASS|SOFT_FAIL|HARD_FAIL` 判定。
- 次に必要な最小入力（1 行）。
